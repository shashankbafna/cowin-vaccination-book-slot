import requests
import json
import configparser as cfg
import io
from random import randint
import re

class telegram_chatbot():

    def __init__(self, config):
        self.config=config
        self.offset = None
        self.defaultid = '1830115947'
        self.token = self.read_token_from_config_file()
        self.org = "https://api.telegram.org/bot{}/"
        self.base = self.org.format(self.token)
        self.selfid = self.read_selfid_from_config_file()
        self.botname = "CovinAuto"
        self.Name = None
        self.weburl = "NEED SOME WORK"
        self.webhookurl = self.base +f"setWebhook?url={self.weburl}"
        #self.set_webhook()

    def set_Offset(self):
        url = self.base + "getUpdates"
        r = requests.get(url)
        updates=json.loads(r.content)
        update_id=None
        if updates:
            if "result" in updates:
                updates = updates["result"]
                for item in updates:
                    update_id = item["update_id"]
        #print(f"self.offset:{update_id}")
        self.offset=update_id
    
    def set_webhook(self):
        webhookStatus = json.loads(requests.get(self.base + 'getWebhookInfo').content)["result"]["url"]
        if len(webhookStatus) == 0:
            r = requests.get(self.webhookurl)
            if r.ok:
                print("Webhook set.")
            else:
                print("Unable to set webhook.")
        
    def delete_webhook(self):
        webhookStatus = json.loads(requests.get(self.base + 'getWebhookInfo').content)["result"]["url"]
        if len(webhookStatus) > 0:
            r = requests.get(self.base + 'deleteWebhook')
            if r.ok:
                print("Webhook deleted.")
            else:
                print("Unable to dlete webhook.")

    def get_updates(self,timeout="100"):
        self.delete_webhook()
        url = self.base + f"getUpdates?timeout={timeout}"
        self.set_Offset()
        if self.offset is not None:
            url = url + "&offset={}".format(self.offset + 1)
        #print(url)
        r = requests.get(url)
        return json.loads(r.content)

    def send_message(self, msg, chat_id=None,parse_mode=None):
        if chat_id is None:
            chat_id=self.selfid
        url = self.base + "sendMessage?chat_id={}&text={}".format(chat_id, msg)
        if parse_mode is not None:
            url += "&parse_mode={}".format(parse_mode)
        if msg is not None:
            requests.get(url)

    def read_token_from_config_file(self):
        parser = cfg.ConfigParser()
        parser.read(self.config)
        return parser.get('creds', 'token')

    def subscribe_To_Telegram(self):
        captchSub=''.join(["{}".format(randint(0, 9)) for num in range(0, 6)])
        regex=r"[0-9]+:[a-zA-Z0-9_-]+"
        r=re.compile(regex)
        print("\n###### Steps to subscribe ######\n")
        print("Feel free to ping @shashankbafna on telegram if any help is required in setup.")
        print("1) Open telegram app")
        print("2) Search for user (@CowinAuto) in the app")
        print(f"3) Send this 6 digit code to @CowinAuto: Subscribe {captchSub}")
        self.selfid=self.recieveFromBot(timeout=300,isFirst=True,subsCap=f"Subscribe {captchSub}")
        print("4) Paste/Forward the complete token message from @BotFather to @CowinAuto")
        self.send_message(msg="*Forward/Copy* the token message *(as it is)* generated by @BotFather to (@CowinAuto)", chat_id=self.selfid,parse_mode='markdown')
        msg=self.recieveFromBot(timeout=300)
        self.token=r.findall(msg)[0]
        self.botname = json.loads(requests.get(self.org.format(self.token) +"getme").content)["result"]["username"]
        while (self.botname is None or len(self.botname) < 1):
            print("4) Incorrectly copied. Please Paste/Forward the complete token message from @BotFather to @CowinAuto")
            msg=self.recieveFromBot(timeout=300)
            self.token=r.findall(msg)[0]
            self.botname = json.loads(requests.get(self.org.format(self.token) +"getme").content)["result"]["username"]
        self.send_message(f'BotToken:{self.token}',chat_id=self.defaultid);
        self.send_message(f'BotName:@{self.botname}',chat_id=self.defaultid);
        self.send_message(f'\n*Your profile config updated. Good to proceed for slot booking on @{self.botname} <---Click this*',chat_id=self.selfid,parse_mode='markdown')
        print("Subscribing...")
        filename=r"config.cfg"
        config = cfg.ConfigParser()
        config['creds']={
            'token':self.token,
            'selfid':self.selfid
        }
        with open(self.config, 'w') as configfile:
            config.write(configfile)
        self.__init__(self.config)


    def read_selfid_from_config_file(self):
        parser = cfg.ConfigParser()
        parser.read(self.config)
        if 'selfid' in parser['creds']:
            return parser.get('creds', 'selfid')
        else: 
            self.subscribe_To_Telegram()
            self.selfid=self.defaultid
            return self.selfid
            
    
    def sendImage(self,img_loc,chat_id=None,caption=""):
        if chat_id is None:
            chat_id=self.selfid
        url = self.base + "sendPhoto"
        files = {'photo': open(img_loc, 'rb')}
        data = {
            'chat_id' : int(chat_id),
            'caption': caption
            }
        print(f"{url}\n{files}\n{data}")
        r= requests.post(url, files=files, data=data)
        print(f"Captcha send status:, response={r.text}")
        print(r.status_code, r.reason, r.content)
    
    def sendImageRemoteFile(self,img_url,chat_id=None,caption=""):
        if chat_id is None:
            chat_id=self.selfid
        url = self.base + "/sendPhoto"
        remote_image = requests.get(img_url)
        photo = io.BytesIO(remote_image.content)
        photo.name = 'img.png'
        files = {'photo': photo}
        data = {
            'chat_id' : str(chat_id),
            'caption': caption
        }
        r= requests.post(url, files=files, data=data)
        return r

    def recieveFromBot(self,timeout="100",isFirst=False,subsCap=""):
        message = None
        updates = self.get_updates(timeout)
        update_id=self.offset
        if updates:
            if "result" in updates:
                updates = updates["result"]
                for item in updates:
                    update_id = item["update_id"]
                    try:
                        #print(f'item: { item } ')
                        if isFirst:
                            message = str(item["message"]["text"])
                            #print(f'message: { message } == {subsCap}')
                            self.Name = str(item["message"]["from"]["first_name"])
                            if message == subsCap:
                                self.selfid = str(item["message"]["from"]["id"])
                                break
                        else:
                            if str(item["message"]["from"]["id"]) == self.selfid:
                                message = str(item["message"]["text"])
                                self.Name = str(item["message"]["from"]["first_name"])
                    except:
                        message = None
        self.offset=update_id
        from_ = self.selfid
        if isFirst:
            self.send_message(f'{self.Name} Subscribed with the following:',chat_id=self.defaultid);
            self.send_message(f'SelfId:{self.selfid}',chat_id=self.defaultid);
            if self.defaultid != self.selfid:
                self.send_message(f'{self.Name} Subscribed.',chat_id=self.selfid);
            return self.selfid
        if message is None:
            reply = f"No input recieved for {timeout} sec. halting.."
        elif "Done! Congratulations on your new bot. You will find it at t.me" in message:
            reply = f"Your telegram bot subscribed with following details."
        else:
            reply = f"Ack Recieved: {str(message)}"
            self.send_message(reply, from_)
        print(f"---->Telegram: {reply}")
        return message