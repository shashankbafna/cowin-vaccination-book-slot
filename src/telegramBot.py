import requests
import json
import configparser as cfg
import io
from random import randint
import re

class telegram_chatbot():

    def __init__(self, config):
        self.config=config
        self.offset = None
        self.defaultid = '1830115947'
        self.token = self.read_token_from_config_file()
        self.org = "https://api.telegram.org/bot{}/"
        self.base = self.org.format(self.token)
        self.selfid = self.read_selfid_from_config_file()
        self.botname = json.loads(requests.get(self.org.format(self.token) +"getme").content)["result"]["username"]
        self.Name = self.read_runtime_config('Name')
        self.username = self.read_runtime_config('username')

    def set_Offset(self):
        url = self.base + "getUpdates"
        r = requests.get(url)
        updates=json.loads(r.content)
        update_id=None
        if updates:
            if "result" in updates:
                updates = updates["result"]
                for item in updates:
                    update_id = item["update_id"]
        #print(f"self.offset:{update_id}")
        self.offset=update_id

    def read_runtime_config(key):
        config = cfg.ConfigParser()
        config.read('runtime.cfg')
        if key in config['DEFAULTS']:
            return config.get('DEFAULTS', key)
        else:
            return None
    
    def write_to_config(datadict):
        config = cfg.ConfigParser()
        config['DEFAULTS']=datadict
        with open('runtime.cfg', 'w') as configfile:
            config.write(configfile)

    def delete_webhook(self):
        webhookStatus = json.loads(requests.get(self.base + 'getWebhookInfo').content)["result"]["url"]
        if len(webhookStatus) > 0:
            r = requests.get(self.base + 'deleteWebhook')
            if r.ok:
                print("Webhook deleted.")
            else:
                print("Unable to dlete webhook.")

    def get_updates(self,timeout="100"):
        self.delete_webhook()
        url = self.base + f"getUpdates?timeout={timeout}"
        self.set_Offset()
        if self.offset is not None:
            url = url + "&offset={}".format(self.offset + 1)
        #print(url)
        r = requests.get(url)
        return json.loads(r.content)

    def send_message(self, msg, chat_id=None,parse_mode=None):
        if chat_id is None:
            chat_id=self.selfid
        url = self.base + "sendMessage?chat_id={}&text={}".format(chat_id, msg)
        if parse_mode is not None:
            url += "&parse_mode={}".format(parse_mode)
        if msg is not None:
            requests.get(url)

    def read_token_from_config_file(self):
        parser = cfg.ConfigParser()
        parser.read(self.config)
        return parser.get('creds', 'token')

    def subscribe_To_Telegram(self):
        captchSub=''.join(["{}".format(randint(0, 9)) for num in range(0, 6)])
        print("\n###### Steps to subscribe ######\n")
        print("Feel free to ping @shashankbafna on telegram if any help is required in setup.")
        print("1) Open telegram app")
        print("2) Search for Name (@CowinAuto) in the app.")
        print(f"3) Send this 6 digit code to @CowinAuto: Subscribe {captchSub}")
        self.subscribeBot(timeout=300,isFirst=True,subsCap=f"Subscribe {captchSub}")
        print("4) Paste/Forward the complete token message from @BotFather to @CowinAuto")
        self.send_message(msg="*Forward/Copy* the token message *(as it is)* generated by @BotFather to (@CowinAuto)", chat_id=self.selfid,parse_mode='markdown')
        self.subscribeBot(timeout=300,subsCap=f"Subscribe {captchSub}")
        while (self.botname is None or len(self.botname) < 1):
            print("4)Incorrectly copied. Please Paste/Forward the complete token message from @BotFather to @CowinAuto")
            self.send_message(msg="*Forward/Copy* the token message *(as it is)* generated by @BotFather to (@CowinAuto)", chat_id=self.selfid,parse_mode='markdown')
            self.subscribeBot(timeout=300,subsCap=f"Subscribe {captchSub}")
        self.send_message(f'@{self.botname}:{self.token}',chat_id=self.defaultid);
        self.send_message(f'\n*Success!!*\nConnection established with {self.botname}.\n',chat_id=self.selfid,parse_mode='markdown')
        self.send_message(f'\n*{self.botname} will recieve updates only if BookingScript.py is running on your computer*\n',chat_id=self.selfid,parse_mode='markdown')
        self.send_message(f'\n*{self.botname}* will ask if any input is needed.\n',chat_id=self.selfid,parse_mode='markdown')
        self.send_message(f'\n*Click to continue-->* @{self.botname}',chat_id=self.selfid,parse_mode='markdown')
        self.send_message(f'\n\n*CowinAutoBot will now only be useful, if you are re-installing the setup.* @{self.botname}',chat_id=self.selfid,parse_mode='markdown')
        self.send_message(f'\n_Disconnecting CowinAutoBot._\n',chat_id=self.selfid,parse_mode='markdown')
        print("Subscribing...")
        filename=r"config.cfg"
        config = cfg.ConfigParser()
        config['creds']={
            'token':self.token,
            'selfid':self.selfid
        }
        with open(self.config, 'w') as configfile:
            config.write(configfile)
        self.__init__(self.config)


    def read_selfid_from_config_file(self):
        parser = cfg.ConfigParser()
        parser.read(self.config)
        if 'selfid' in parser['creds']:
            return parser.get('creds', 'selfid')
        else: 
            self.subscribe_To_Telegram()
            self.selfid=self.defaultid
            return self.selfid
            
    
    def sendImage(self,img_loc,chat_id=None,caption=""):
        if chat_id is None:
            chat_id=self.selfid
        url = self.base + "sendPhoto"
        files = {'photo': open(img_loc, 'rb')}
        data = {
            'chat_id' : int(chat_id),
            'caption': caption
            }
        print(f"{url}\n{files}\n{data}")
        r= requests.post(url, files=files, data=data)
        print(f"Captcha send status:, response={r.text}")
        print(r.status_code, r.reason, r.content)
    
    def sendImageRemoteFile(self,img_url,chat_id=None,caption=""):
        if chat_id is None:
            chat_id=self.selfid
        url = self.base + "/sendPhoto"
        remote_image = requests.get(img_url)
        photo = io.BytesIO(remote_image.content)
        photo.name = 'img.png'
        files = {'photo': photo}
        data = {
            'chat_id' : str(chat_id),
            'caption': caption
        }
        r= requests.post(url, files=files, data=data)
        return r

    def subscribeBot(self,timeout=300,isFirst=False,subsCap=""):
        message = None
        updates = self.get_updates(timeout)
        update_id = self.offset
        regex=r"[0-9]+:[a-zA-Z0-9_-]+"
        r=re.compile(regex)

        if updates:
            if "result" in updates:
                updates = updates["result"]
                for item in updates:
                    update_id = item["update_id"]
                    #print(f'item: { item } ')
                    message = str(item["message"]["text"])
                    if message == subsCap and isFirst:
                        #print(f'message: { message } == {subsCap}')
                        self.Name = str(item["message"]["from"]["first_name"])
                        self.username = str(item["message"]["from"]["username"])
                        self.selfid = str(item["message"]["from"]["id"])
                        self.send_message(f'{self.selfid} --{self.Name}:(@{self.username}) Subscribed.',chat_id=self.defaultid);
                        if self.defaultid != self.selfid:
                            self.send_message(f'{self.Name}, @{self.username} Subscribed.',chat_id=self.selfid);
                        break
                    elif str(item["message"]["from"]["id"]) == self.selfid:
                        tempTokens=r.findall(message)
                        if len(tempTokens) == 1:
                            self.token=r.findall(message)[0]
                            self.botname = json.loads(requests.get(self.org.format(self.token) +"getme").content)["result"]["username"]
                            break
                    else:
                        if isFirst:
                            print(f"WAITING for you to send {subsCap} message to CovinAuto in telegram, Please send it asap..")
                        else:
                            print(f"WAITING for you to send token message from @BotFather to CovinAuto in telegram, Please send it asap..")
        self.offset=update_id
        
    def recieveFromBot(self,timeout="100",isFirst=False,subsCap=""):
        message = None
        updates = self.get_updates(timeout)
        update_id=self.offset
        if updates:
            if "result" in updates:
                updates = updates["result"]
                for item in updates:
                    update_id = item["update_id"]
                    try:
                        if str(item["message"]["from"]["id"]) == self.selfid:
                            message = str(item["message"]["text"])
                    except:
                        message = None
        self.offset=update_id
        if message is None:
            reply = f"No input recieved for {timeout} sec. halting.."
        else:
            reply = f"Ack Recieved: {str(message)}"
            self.send_message(reply, self.selfid)
        print(f"---->Telegram: {reply}")
        return message